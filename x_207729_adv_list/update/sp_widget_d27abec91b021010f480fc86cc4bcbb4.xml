<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[function test($location, $httpParamSerializer) {
	/* widget controller */
	var c = this;

	c.currentPage = 0;
	c.maxPage = 0;
	c.displayControls = false;
	c.emptyCache = true;
	c.items = [];

	
	function init() {
		c.selectedSorting = c.data.sortingOptions[0];
		c.searchInput = $location.search().s;
		c.initializedSources = c.data.initializedSources;
		updateData("init", c.selectedSorting, c.currentPage, c.emptyCache, c.searchInput);
	}


	function updateData(action, sorting, currentPage, emptyCache, searchTerm) {
		
		/*
		var inputs = {
			action: action,
			sorting: sorting,
			searchTerm: searchTerm,
			currentPage: currentPage,
			initializedSources: c.initializedSources
		};

		c.loading = true;
		c.server.get(inputs).then(function(response){
			c.items = c.items.concat(response.data.results);
			c.loading = false;
			c.displayControls = true;
		});
		*/
		
		c.data.action = action;
		c.data.sorting = sorting;
		c.data.currentPage = currentPage;
		c.data.emptyCache = emptyCache;
		c.data.searchTerm = searchTerm;
		c.loading = true;
		c.server.update().then(function (response) {
			console.log(response);
			c.items = response.results;
			c.maxPage = Math.ceil(response.totalNoRecords/response.pageSize - 1);
			c.data.action = undefined;
			c.displayControls = true;
			c.emptyCache = true;
			c.loading = false;
		});
	}


	c.reload = function () {
		if (c.loading) {
			return;
		}
		updateData("load", c.selectedSorting, c.currentPage, c.emptyCache, c.searchInput);
	};



	// TODO: Move search and sorting to it's own widget??
	c.search = function () {
		// removes s param from url on empty search string
		if (c.searchInput === "") {
			c.searchInput = undefined;
		}

		if (c.searchInput !== c.data.searchTerm) {
			var parms = $location.search();
			parms.s = c.searchInput;
			parms.spa = 1;
			$location.search(parms);
			c.currentPage = 0;
			c.reload();
		}
	};



	c.clearSearch = function () {
		c.searchInput = undefined;
		c.search();
	};



	c.loadMore = function() {
		if(c.currentPage === c.maxPage){
			return;
		}
		c.currentPage += 1;
		c.emptyCache = false;
		c.reload();
	};



	c.previousPage = function() {
		if(c.currentPage === 0){
			return;
		}
		c.currentPage -= 1;
		c.reload();
	};



	c.goToPage = function(pageNo) {
		if(c.currentPage === pageNo){
			return;
		}
		c.currentPage = pageNo;
		c.reload();
	};



	c.generateURL = function (urlObj) {
		var url = "",
			serializedParams = $httpParamSerializer(urlObj.parms);

		if (urlObj.type === 'url') {
			url = urlObj.base_url;
		}

		if (serializedParams.length > 0) {
			url += ((url.indexOf('?') === -1) ? '?' : '&') + serializedParams;
		}
		return url;
	};


	init();

}]]></client_script>
        <controller_as>c</controller_as>
        <css>.list-group-horizontal .list-group-item {
	display: inline-block;
}

.list-group-horizontal .list-group-item {
	margin-bottom: 0;
	margin-left: -4px;
	margin-right: 0;
	border-right-width: 0;
}

.list-group-horizontal .list-group-item:first-child {
	border-top-right-radius: 0;
	border-bottom-left-radius: 4px;
}

.list-group-horizontal .list-group-item:last-child {
	border-top-right-radius: 4px;
	border-bottom-left-radius: 0;
	border-right-width: 1px;
}

#controls {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;

	.search {
		flex: 1 0 auto;

		.input-group {
			width: 100%;
		}
	}

	.sort {
		flex: 1 0 auto;
		display: flex;
		justify-content: flex-end;
		align-items: baseline;
	}
}

#items {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;

	li {
		flex: 0 1 calc(25% - 1em);
		padding: 1rem;
		@media(min-width: 40rem) {
		  width: 50%;
		}
		@media(min-width: 56rem) {
		  width: 33.3333%;
		}
	}
}

#item-list,
#errors,
#controls {
	margin-bottom: 10px;

	ul {
		list-style: none;
	}

	#items {
		padding: 0;
	}
}

.item-body {
	/*
	display: flex;
	justify-content: space-between;
	*/

	.item-type,
	.item-content {
		display: block;
		text-align: center;
		//display: flex;
	}

	.item-type {
		flex: 1 0 8%;
		flex-direction: column;
		align-items: center;
	}

	.item-content {
		flex: 2 0 92%;
		flex-wrap: wrap;

		.item-title {
			flex: 1 0 100%;
			margin: 0;
		}

		.primary-content {
			flex: 3 0 80%;
			padding-right: 1%;
		}

		.secondary-content {
			flex: 1 0 20%;
			padding-left: 1%;
			border-left: 1px solid $primary;
		}
	}
}

@media (max-width: 768px) {
	#controls, #controls .sort {
		display: block;
		text-align: center;
	}

	.item-body,
	.item-body .item-content {
		display: block;
	}

	.item-body .item-content {
		text-align: center;

		.item-title,
		.primary-content,
		.secondary-content {
			padding: 5% 0;
		}

		.secondary-content {
			border-left: none;
			border-top: 1px solid $primary;
		}
	}

}
</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>false</has_preview>
        <id>sp-advanced-list</id>
        <internal>false</internal>
        <link><![CDATA[function link (scope, element, attrs, controller) {
    var lazyLoader = $injector.get("lazyLoader");
    lazyLoader.putTemplates(scope.data.listTemplates);
}]]></link>
        <name>SP Advanced List</name>
        <option_schema>[{"displayValue":"List Sources","name":"list_sources","display_value_list":[],"section":"Data","label":"List Sources","type":"glide_list","value":"x_207729_adv_list_item_definition","ed":{"reference":"x_207729_adv_list_item_definition"}}]</option_schema>
        <public>false</public>
        <roles/>
        <script><![CDATA[(function () {
  // CONSTANTS
  var PAGE_SIZE = 12,
    LIST_SOURCE_TABLE = "x_207729_adv_list_item_definition",
    CONFIG_FIELDS = [
      "active",
      "table",
      "id",
      "title_field",
      "primary_fields",
      "secondary_fields",
      "meta_fields",
      "filter",
      "item_icon",
      "item_template",
      "type",
      "link_url",
      "link_parameters",
      "page"
    ],
    SORTING_OPTIONS = [{
      'id': 1,
      'field': 'title',
      'display': gs.getMessage('title_AZ'),
      'orderAsc': true
    }, {
      'id': 2,
      'field': 'title',
      'display': gs.getMessage('title_ZA'),
      'orderAsc': false
    }, {
      'id': 3,
      'field': 'sys_created_on',
      'display': gs.getMessage('Newest'),
      'orderAsc': false
    }, {
      'id': 4,
      'field': 'sys_created_on',
      'display': gs.getMessage('Oldest'),
      'orderAsc': true
    }, {
      'id': 5,
      'field': 'sys_updated_on',
      'display': gs.getMessage('Latest modified'),
      'orderAsc': false
    }, {
      'id': 6,
      'field': 'sys_updated_on',
      'display': gs.getMessage('Oldest modified'),
      'orderAsc': true
    }];

  var initializedSources = [];
  data.sortingOptions = SORTING_OPTIONS;
  data.pageSize = PAGE_SIZE;
  data.totalNoRecords = 0;
  data.cachedResults = [];


  // in order to keep the options beyond initial load we need to pass them to data object
  if (options) {
    data.options = options;
  }

  // making the widget async
  if (!input) {
    //initialize the table instances on the first load so template can be cached
    initializedSources = initializeListSources(options.list_sources, LIST_SOURCE_TABLE, CONFIG_FIELDS);
    data.initializedSources = initializedSources;
    return;
  }

  // set options from input
  if (input.options) {
    options = input.options;
  }

  var orderBy = input.sorting.field,
    orderAsc = input.orderAsc,
    pagination = {
      start: input.currentPage * PAGE_SIZE,
      end: input.currentPage * PAGE_SIZE + PAGE_SIZE
    },
    searchTerm = input.searchTerm;
  initializedSources = input.initializedSources;



  //TODO: add action to empty set cache to empty when jumping to specific page of results
  // TODO: make result caching work when pagination goes towards beginning
  if (input.action === 'init') {
    load();
  }

  if (input.action === 'load') {
    load(input.cachedResults, input.emptyCache);
  }



  function load(cache, emptyCache) {
    if (!initializedSources) {
      errorMsgProvider('configuration');
      return;
    }

    data.initializedSources = initializedSources;
    var records = initializedSources.map(function (instance) {
      return getData(instance, orderBy, orderAsc, pagination, searchTerm);
    });
    if (cache && cache.length !== 0 && !emptyCache) {
      records.push(cache); // if we have records in cache then include them to result compilation
    }
    var results = compileResults(records, input.sorting.field, input.sorting.orderAsc);
    if (results.length > PAGE_SIZE) {
      data.results = results.slice(0, PAGE_SIZE);
      data.cachedResults = results.slice(PAGE_SIZE);
    } else {
      data.results = results;
    }
  }
})();

function initializeListSources(listSources, listSourceTable, configurationFields) {
  if (listSources.length === 0) {
    errorMsgProvider('configuration');
    return;
  }
  var sources = listSources.split(",");

  // TODO: should listTemplates be handled in its own function?
  data.listTemplates = {};
  var sourceConfigs = sources.map(function (source) {
    var sourceGr = new GlideRecord(listSourceTable);
    sourceGr.get(source);
    if (!sourceGr.isValidRecord() || sourceGr.getValue('active') === '0') {
      errorMsgProvider("table");
      return;
    }
    var t = {};
    for (var i = 0, j = configurationFields.length; i < j; i++) {
      t[configurationFields[i]] = sourceGr.getValue(configurationFields[i]);
    }
    data.listTemplates["sp-template-" + t.id + ".html"] = $sp.translateTemplate(t.item_template); //using undocumented ServiceNow function to generate the list templates dynamically from record data
    return t;
  });
  return sourceConfigs;
}



function getData(tableInstance, orderBy, orderAsc, pagination, searchTerm) {
  if (orderBy === 'title') {
    orderBy = tableInstance.title_field;
  }
  var query = generateGliderecord(tableInstance.table, tableInstance.filter, orderBy, orderAsc, pagination, searchTerm);
  data.totalNoRecords += parseInt(getNoRecords(tableInstance.table, query.getEncodedQuery()));
  var records = generateRecords(query, tableInstance);
  return records;
}


/**
 * 
 * @param {string} table name of the table where the query is constructed
 * @param {string} filter filter to be applied 
 * @param {string} orderBy field name to order the query
 * @param {boolean} orderAsc ascending (true) or descencing (false, default) ordering
 * @param {int} limit how many records should be returned from the query
 * @returns {glideRecord obj} queried gliderecord object
 */
function generateGliderecord(table, filter, orderBy, orderAsc, pagination, searchTerm) {

  var query = new GlideRecord(table);
  if (!query.isValid()) {
    errorMsgProvider('table', table, $sp.getValue('title'));
    return;
  }

  if (filter) {
    query.addEncodedQuery(filter);
  }

  if (searchTerm) {
    query.addQuery('123TEXTQUERY321', searchTerm);
    //query.addQuery('IR_AND_OR_QUERY', searchTerm);
  }
  if (orderAsc === true ? query.orderBy(orderBy) : query.orderByDesc(orderBy));

  if(pagination) {
    query.chooseWindow(pagination.start, pagination.end);
  }
  
  query.query();
  return query;
}



function getNoRecords(table, encodedQuery) {
  var noRecords = 0,
    count = new GlideAggregate(table);
  count.addEncodedQuery(encodedQuery);
  count.addAggregate('COUNT');
  count.query();

  if (count.next()) {
    noRecords = count.getAggregate('COUNT');
  }
  return noRecords;
}




function generateRecords(query, tableInstance) {
  var items = [],
    t = tableInstance;

  while (query.next()) {
    var record = {};
    record = {
      sys_id: query.getValue('sys_id'), //get sys_id for every record
      sys_created_on: query.getValue('sys_created_on'), // sorting
      sys_updated_on: query.getValue('sys_updated_on'), // sorting
      sys_class_name: query.getDisplayValue('sys_class_name'),
      icon: t.item_icon, //form FontAwesome icon name for the record
      templateID: "sp-template-" + t.id + ".html", // form the record template name
      title: {},
      primary_fields: {},
      secondary_fields: {},
      meta_fields: {}
    };

    //we need to use $sp.getRecord* to access dot-walked fields in scoped application
    $sp.getRecordDisplayValues(record.title, query, t.title_field);
    $sp.getRecordElements(record.primary_fields, query, t.primary_fields);
    $sp.getRecordElements(record.secondary_fields, query, t.secondary_fields);
    $sp.getRecordElements(record.meta_fields, query, t.meta_fields);

    record.url = generateURL(record, {
      'type': t.type,
      'page': t.page,
      'base_url': t.link_url,
      "parms": t.link_parameters
    });
    record.title = record.title[Object.keys(record.title)[0]]; // making the record title display value easier to access in final sorting and HTML
    items.push(record);
  }
  return items;
}



function generateURL(record, urlObj) {
  var parms = JSON.parse(urlObj.parms);
  var url = {
    type: urlObj.type,
    base_url: urlObj.base_url || "",
    parms: {}
  };

  if (urlObj.type === 'page') {
    var pageGr = new GlideRecord('sp_page');
    pageGr.get(urlObj.page);
    url.parms.id = pageGr.getValue('id');
  }

  for (var p in parms) {
    // check if the property/key is defined in the object itself, not in parent
    if (parms.hasOwnProperty(p)) {
      var meta = record.meta_fields[p] || record.meta_fields[parms[p]] || null; //check meta_fields for the url property
      if (meta) {
        meta = meta.value;
      }
      url.parms[p] = meta || record[p] || parms[p] || null; //setting the param value, first check meta_fields for the value, then record values and param values
    }
  }
  return url;
}



/**
 * 
 * @param {arr} data array of objects containing list records
 * @param {string} orderBy field name to order the array by
 * @param {boolean} orderAsc should the data be ordered ascending
 * @param {int} limit how many items are returned after sorting
 * @returns {arr} limited number of list record after sorting
 */
function compileResults(data, orderBy, orderAsc, limit) {
  var sortArr = [].concat.apply([], data); //data contains queried records in multiple arrays so we must combine them
  if (orderAsc === true) {
    sortAsc(sortArr, orderBy);
  } else {
    sortDesc(sortArr, orderBy);
  }
  return sortArr;
}



/**
 * 
 * @param {arr} arr array to sort
 * @param {string} sortBy object property name to sort by
 */
function sortAsc(arr, sortBy) {
  return arr.sort(function (a, b) {
    if (a[sortBy] < b[sortBy]) {
      return -1;
    }
    if (a[sortBy] > b[sortBy]) {
      return 1;
    }
    return 0;
  });
}



/**
 * 
 * @param {arr} arr array to sort
 * @param {string} sortBy object property name to sort by
 */
function sortDesc(arr, sortBy) {
  return arr.sort(function (a, b) {
    if (a[sortBy] > b[sortBy]) {
      return -1;
    }
    if (a[sortBy] < b[sortBy]) {
      return 1;
    }
    return 0;
  });
}



/**
 * 
 * @param {string} errorType possible errors "configuration" or "table"
 * @param {string} arg1 table name to be added to the error message
 * @param {string} arg2 widget identifier for error message
 */
function errorMsgProvider(errorType, arg1, arg2) {
  data.error = true;
  data.errorMessages = [];
  switch (errorType) {
    case 'configuration':
      data.errorMessages.push("Table configuration is not available for this widget. Please contact your system administrator.");
      break;
    case 'table':
      data.errorMessages.push("One of tables provided for widget is not valid.");
      gs.warn("The table ({0}) provided for widget ({1}) is not valid.", arg1, arg2);
      break;
    default:
      data.errorMessages.push("An error occurred, please try again later. If the problem persists contact your system administrator.");
  }
}]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2020-07-15 09:23:49</sys_created_on>
        <sys_id>d27abec91b021010f480fc86cc4bcbb4</sys_id>
        <sys_mod_count>569</sys_mod_count>
        <sys_name>SP Advanced List</sys_name>
        <sys_package display_value="SP Advanced List" source="x_207729_adv_list">09a2f2811b021010f480fc86cc4bcbf0</sys_package>
        <sys_policy/>
        <sys_scope display_value="SP Advanced List">09a2f2811b021010f480fc86cc4bcbf0</sys_scope>
        <sys_update_name>sp_widget_d27abec91b021010f480fc86cc4bcbb4</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2020-08-11 12:15:21</sys_updated_on>
        <template><![CDATA[<div id="title" class="col-xs-12" role="">
    <h1>{{::options.title || "Hello there!"}}</h1>
</div>

<section id="errors" ng-if="data.error" class="col-xs-12">
    <ul>
        <li ng-repeat="error in data.errorMessages" class="alert alert-warning">
            {{error}}
        </li>
    </ul>
</section>

<section id="controls" class="col-xs-12 form-inline" ng-if="c.displayControls">

    <div class="form-group search">
        <div class="input-group">
            <input type="text" class="form-control" placeholder="Search for..." ng-model="c.searchInput"
                ng-disabled="c.loading">
            <div class="input-group-btn">
                <button class="btn btn-default" type="button" ng-click="c.search()"
                    ng-disabled="c.loading">${search}</button>
                <button class="btn btn-danger" type="button" ng-click="c.clearSearch()"
                    ng-disabled="c.loading">${clear}</button>
            </div>
        </div>
    </div>

    <div class="form-group form-inline sort">
        <label for="sortingMenu">${sort_by_text}</label>
        <select class="form-control" name="sortingMenu" id="sortingMenu"
            ng-options="option as option.display for option in data.sortingOptions track by option.id"
            ng-model="c.selectedSorting" ng-change="c.reload()" ng-disabled="c.loading">
        </select>
    </div>

    <!-- REMOVE PAGINATION-->
    <!--div class="col-xs-12">
        <nav class="center-block" ng-if="c.maxPage > 0">
            <ul class="pagination">
                <li class="previous"><a href="#" ng-click="c.previousPage()" ng-if="c.currentPage != 0">Previous page</a></li>
                <li ng-repeat="x in [].constructor(c.maxPage) track by $index"><a href="#"
                        ng-click="c.goToPage($index)">{{$index + 1}}</a></li>
                <li class="next"><a href="#" ng-click="c.nextPage()" ng-if="c.currentPage != c.maxPage">Next page</a></li>
            </ul>
        </nav>
    </div-->

    <!-- PURELY FOR DEVELOPMENT PURPOSES -->
    <div class="col-xs-12">
        <ul class="center-block">
            <li>Total number of records is: {{c.data.totalNoRecords}}</li>
        </ul>
    </div>

</section>

<section id="item-list" class="col-xs-12">

    <ul id=items>
        <li class="panel panel-default" ng-repeat="item in c.items">
            <a class="panel-body item-body" ng-href="{{c.generateURL(item.url)}}">

                <!-- if icon is available we'll show that and the class name of item -->
                <div ng-if="item.icon !== null && item.icon !== undefined" class="item-type">
                    <div class="fa fa-2x" ng-class="'fa-' + item.icon"></div>
                    <small class="text-muted">{{value.sys_class_name}}</small>
                </div>

                <!-- template provided in list source definition -->
                <div ng-include="item.templateID" class="item-content"></div>

                <!-- using the back-up list template on when no template is provided -->
                <div ng-if="data.listTemplates[item.templateID] == null">
                    <h3>{{item.title}}</h3>
                    <p ng-repeat="field in item.primary_fields">{{field.display_value}}</p>
                </div>

            </a>
        </li>
    </ul>

</section>

<section>
    <div class="col-xs-12">
        <button type="button" class="btn btn-default" ng-disabled="c.loading" aria-label="${loadMoreItems}" ng-click="c.loadMore()">${loadMoreItems}</button>
    </div>
</section>]]></template>
    </sp_widget>
</record_update>
